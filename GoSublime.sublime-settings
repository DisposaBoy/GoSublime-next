{
	// The maximum amount of memory(MiB) that MarGo is allowed to use
	"margo_oom": 1000,

	// you may set specific environment variables here
	// e.g "env": { "PATH": "$HOME/go/bin:$PATH" }
	// in values, $PATH and ${PATH} are replaced with
	// the corresponding environment(PATH) variable, if it exists.
	"env": {},

	// if set, whenever possible `GOPATH` will be set to `GS_GOPATH`.
	// please see `Usage & Tips` `ctrl+dot,ctrl+2`
	// section `Per-project  settings & Project-based GOPATH` for details about `GS_GOPATH`
	"use_gs_gopath": false,

	// Your shell. e.g. on Linux and OS X, if your shell bash:
	// you may set it to ["/bin/bash", "--login", "-c", "$CMD"]
	// it's useful to pass the --login argument in order for it run your ~/.bashrc etc.
	// otherwise environment variables may not be seen by Sublime Text and therefore GoSublime
	//
	// If set, commands are passed to it instead of the Python default which for *nix is usually
	// /bin/sh which in most cases is not what you want
	//
	// the special entry "$CMD" is replaced by the actual command
	"shell": [],

	// whether or not pkg files should be automatically saved when necessary (e.g. when running 9o `replay` or `go test` commands)
	"autosave": true,

	// Whether or not gscomplete(gocode) is enabled
	"gscomplete_enabled": true,

	// Whether or not fmt the file when it's saved
	"fmt_on_save": true,

	// by default fmt'ing is done by margo. you may use a command of your choosing by setting `fmt_cmd`
	// e.g. ["goimports"]
	// the command will be passed, to its stdin, the contents of the file
	// it must output the new file contents
	"fmt_cmd": [],

	// whether or not to include snippets in the auto-completion list
	"autocomplete_snippets": true,

	// whether or not to include Test*, Benchmark* and Example* functions in the auto-completion list
	"autocomplete_tests": false,

	// whether or not builtin types and functions should be shown in the auto-completion list
	"autocomplete_builtins": false,

	// whether or not to show an expanded(closure) version of func types in the auto-completion list
	// e.g. `type Fun func(i int)`
	// will result in two entries `Fun` and `Fun {}`
	// expanding to `Fun` and `func(i) {...}` respectively
	"autocomplete_closures": false,

	// you may set this to a regexp which will be used to filter entries in the auto-completion list
	// e.g. "autocomplete_filter_name": "^autogenerated_" will prevent any type or function
	// whose name begins with "autogenerated_" from appearing in the auto-completion list
	"autocomplete_filter_name": "",

	// whether or not autocomplete should suggest possible imports when autocomplete fails to
	// find a match.
	// note: this feature only comes into effect when autocomplete was triggered after a dot, e.g. `fmt.|`
	"autocomplete_suggest_imports": false,

	// whether or not to show function call tip in the status bar
	// the same can be achieved ctrl+dot,ctrl+space using an output panel
	"calltips": true,

	// whether or not to use named imports when the basename of the import path doesn't match the pkg name
	// e.g. gosubli.me/go-foo would be imported as:
	//     import (
	//         foo "gosubli.me/go-foo"
	//     )
	"use_named_imports": false,

	// whether or not to import `.a` files ...
	// the alternative is to search your $GOROOT/src/pkg and $GOPATH*/src for packages
	// WARNING: when this is set to `true` `use_named_imports` above will have no effect.
	"use_legacy_imports": true,

	// whether or not MarGo may automatically run `go install` for packages that are missing
	// when you `import`, or `autocomplete` them
	"autoinst": true,

	// the installsuffix to use for autocompletion, autoinst, pkg imports etc.
	// e.g. if you are developing on appengine, you can set it to "appengine"
	// note: attempts *might* be made to call the `go` command with `go -installsuffix` if this is set
	"installsuffix": "",

	// commands to run on (post) save - list of objects of the form {"cmd": "...", "args": {...}}
	"on_save": [],

	// as an alternative to Sublime Text's snippet system you may add snippets to GoSublime's
	// code-completion by adding them to your user settings in the same format as bellow.
	//
	// "snippets": [
	//     {
	//         "match": {"global": true}, // these snippets will only be presented in the global scope
	//         "snippets": [
	//             {"text": "init", "title": "func init()", "value": "func init() {\n\t$1\n}"}
	//         ]
	//     },
	//     {
	//         "match": {"local": true}, // these snippets will only be present in a function scope
	//         "snippets": [
	//             {"text": "print", "title": "print(...)", "value": "print($1)"},
	//             {"text": "println", "title": "println(...)", "value": "println($1)"}
	//         ]
	//     }
	// ]
	//
	// you maybe add field markers ($1, $2, etc) to the `value` string to dictate where the cursor is place
	// once a completion is expanded and where it's placed once you press tab afterwards.
	// duplicate markers e.g f("...", $1, $1) will result in multiple cursors, one for each duplication.
	"snippets": [],

	"default_snippets": [
		{
			"match": {"global": false, "pkgname": ""},
			"snippets": [
				{"text": "package ${default_pkgname}", "title": "", "value": "package ${default_pkgname}\n\n$1\n"}
			]
		},
		{
			"match": {"global": true, "pkgname": "^main$"},
			"snippets": [
				{"text": "func main", "title": "func main {...}", "value": "func main() {\n\t$0\n}\n"}
			]
		},
		{
			"match": {"global": true, "pkgname": "."},
			"snippets": [
				{"text": "import", "title": "import (...)", "value": "import (\n\t\"$1\"\n)"},
				{"text": "func", "title": "func {...}", "value": "func ${1:name}($2)$3 {\n\t$0\n}"},
				{"text": "var", "title": "var (...)", "value": "var (\n\t$1\n)"},
				{"text": "const", "title": "const (...)", "value": "const (\n\t$1\n)"},
				{"text": "init", "title": "func init()", "value": "func init() {\n\t$1\n}"},
				{
					"text": "func http handler",
					"title": "func(rw, req)",
					"value": "func ${1:name}(rw http.ResponseWriter, req *http.Request) {\n\t$0\n}"
				}
			]
		},
		{
			"match": {"global": true, "pkgname": ".", "has_types": true},
			"snippets": [
				{
					"text": "func (*${typename})",
					"title": "func (...) {...}",
					"value": "func (${1:${typename_abbr}} ${2:*}${typename}) ${3:name}($4)$5 {\n\t$0\n}"
				}
			]
		},
		{
			"match": {"local": true},
			"snippets": [
				{"text": "func", "title": "func{...}()", "value": "func($1) {\n\t$0\n}($2)"},
				{"text": "var", "title": "var [name] [type]", "value": "var ${1:name} ${2:type}"}
			]
		}
	],

	// whether or not 9o should ask Sublime Text to show(scroll to) the end of a command's output
	// by default it will attempt to show the beginning
	"9o_show_end": false,

	// if set, 9o will run in single-instance mode instead of per-pkg
	// the name can be any string, so you can e.g. set it per-project and maintain project-specific
	// command history
	"9o_instance": "",

	// if set 9o will use the specified color scheme.
	// the path must relative to `Packages` e.g. `Packages/My/9o Specific.tmTheme`
	// `""` essentially means no color_scheme (like the Sublime Text console)
	// `"default"` leaves it as-is, i.e. matching the color_scheme that's being used for your other views
	"9o_color_scheme": "default",

	// a mapping of names to string commands e.g. `{"ci": "git ci $_args"}`
	// the environment variable `$_args` will be the raw, un-parsed argument passed to the command such that,
	// in the command `ci a.go    b.go`, `$_args` will be `a.go    b.go`
	// and the alias above expands to `git ci a.go    b.go`
	//
	// aliases are resolved recursively so they can be re-used, however recursive aliases are not supported.
	// e.g. if you define an alias `"gs-git": "git --git-dir=... $_args"`,
	// it will be used in the alias `"gs-ci": "gs-git commit $_args"`
	// but an alias `"git": "git $_args"` will fail because it resolves to itself.
	// you can, however create the alias `"git": "$HOME/git/bin/git"` which allows you to add commands
	// to 9o without them needing to appear in your $PATH
	//
	// examples
	// {
	//  	"git": "/usr/bin/git $_args", // call git directly, otherwise it's run through your `shell`
	//  	"ci": "git commit $_args",
	//  	"ci.": "ci $_fn", // $_fn points to the abs path of the current file
	//  	"gro": "sh grep $_args 2>/dev/null", // call grep through your shell and discard stderr
	// }
	//
	"9o_aliases": {},

	// N/I
	// commands is a mapping of 9o command names to objects describing the command (below)
	// for convenience:
	//     if a command is an array e.g. ["echo", "abc"] it will be automatically
	//     converted to an object in the follow way:
	//         the first element in the array will become `cmd` and the rest `args`
	//         i.e. { "cmd": "echo", "args": ["abc"]}
	//
	//      if a command is a string e.g. `/bin/echo` it will be translated into { "cmd": "/bin/echo" }
	//
	// if the command name starts with a dot e.g. `.go-lint`, it will be hidden from the ui, e.g. not autocompleted.
	// the prefix `gs.` is reserved for GoSublime's use and such commands are also hidden from the ui.
	// See also, the `hidden` `ui` option (below)
	"commands": {
		"": {
			// all cancellable command (excuted via margo) are uniquely identified
			// setting cid to a fixed value means that if you run the same command more than once
			// any previous un-finished instance will be killed before starting a new one
			// e.g. `"srv": {"cid": "my-id", "name": "web-srv"}` will kill the old server before starting a new one
			"cid": "",

			"ui": {
				// an alternative, more human-friendly title to be used for e.g. in the quick command panel (+dot,+c)
				// instead of the command name
				"title": "",

				// if `true` this command will be hidden from the ui (e.g. autocompletion)
				"hidden": false,
			},

			// a list of attr mappings to passed to the command
			"attrs": [],

			// write this string to the command's stdin
			// if it's set to the boolean `true`, the contents of the current view will be used instead.
			"input": "",

			// whether or not to discard output on stdout and/or stderr
			// please note: from the 9o POV, each command has only 1 output stream (stdout and stderr are combined)
			"discard_stdout": false,
			"discard_stderr": false,

			// whether or not to save all files in the wd before running the command (below)
			"save": false,

			// run the specified list of commands iff this command succeeds
			// each command is run iff, the one before it succeeds
			// i.e. `this && cmd1 && cmd2 && cmd3`
			"all": [],

			// run the specified list of commands iff this command fails
			// each command is run iff, the one before it fails
			// i.e. `this || cmd1 || cmd2 || cmd3`
			"any": [],

			// run the specified list of commands after this command completes whether or not it fails
			// i.e. `this ; cmd1 ; cmd2 ; cmd3`
			"each": [],

			// run the command from this directory. by default it's the current 9o working directory
			"wd": "",

			// a map of string values. these are layered on top of the command environment variables
			// overwriting any conflicting keys
			"env": {},

			// match each line of output (both stdout and stderr) with the following list of patterns
			// in a switch/case-like fashion
			// each case is checked in order until one matches
			"switch": [
				{
					// the pattern to match. an empty pattern always matches and can thus be used as
					// a type of `default` case which is useful for e.g. keeping matches lines
					// and discarding everything else
					"case": "",

					// if not empty, this object is added to the list of `out-attrs` that is returned by the command.
					// named groups within the pattern above are extracted and layered on top
					// for conflicting keys, if the pattern's value is not empty it will overwrite
					// the value in this object allow it to act as map of default values
					//
					"attr": {
						// if the entry `gs.highlight` is set, the attr will be used to do highlighting
						// that is, lines may be marked with an icon in the gutter and e.g. an error
						// message in the status bar when the cursor is on a particular line
						//
						// the value is the context in which the highliting is being done.
						// all previous highlights within the same context from previous command invocations
						// are cleared before applying highlights from this invocation
						"gs.highlight": "",

						// the following entries are usually matched by a pattern instead of being
						// hard-coded, but they will also be used for highlighting
						//
						// a sample `case` that provides these values is `(?P<fn>\\S+\\.go):(?P<pos>[\\d:]+)(?P<message>.+)`

						// the name of the. ideally this should be an absolute path,
						// but that's not required as relative paths will resolved relative to `wd` (above).
						// if not set, the highlighting will be done against the view that was
						// active at the time of command execution
						"fn": "",

						// the position that should be highlighted
						// it may be `line` (13) or `line:column` (13:4) . the string is interpreted in the following way
						// * split the string by non-numeric characters, ignoring empty matches (e.g. pat `([0-9]+)`)
						// * if there are any matches, the first will become the `line` to highlight
						// * if there are more than one match, the second will become the `column` to match
						// * all other matches are ignored
						"pos": "",

						// the message that should be added to status bar when the cursor is on `line`
						"message": "",

						// if `fn` is not set, it will be create by joining `dirname` and `basename`
						"dirname": "",
						"basename": ""
					},

					// whether or not to do a negative match
					"negative": false,

					// whether or not to discard the line that matched
					"discard": false,

					// whether or not to continue to the next case
					"fallthrough": false
				}
			],

			// if this is `true`, the result of the command will be `ok=true` if there were no matches in switch,
			// if there was a match, then it will be `ok=false`
			"switch_ok": true,

			// if set, `cmd` refers to the final executable commnd,
			// and no further extension is done. supported values are:
			// sh:
			//     construct a *string* by join `cmd` (without extension) and `args` separated by a single `space`
			//     and pass it to your shell. see the `shell` setting
			//     e.g. `"echo": {"cmd": "echo", "args": ["1", "2", "3"]}` will become `/bin/bash -l -c 'echo 1 2 3'`
			//
			// os:
			//     `cmd` refers to an Operating System command/binary in your $PATH
			//     that is: command extension does not take place. see `command extension:` below
			//     this is useful for resolving recursive command definitions where
			//     `a` calls `b` and `b` calls `/usr/bin/a` as `a`
			//     for convenience, of `cmd` refers to this command or is missing, the command is considered to be `final: "os"`
			//     so `"echo": {"cmd": "echo"}` or `"echo": {}` is essentially `"echo": {"cmd": "/bin/echo"}`
			//     but `"echo": {"cmd": "echo-bin"}, "echo-bin": {"cmd": "echo"}` will fail because of the recursion
			"final": "",

			// in both cmd and args, env vars e.g. $HOME and $_wd are expanded using `env` (above)

			// todo: it would be usefull to be able to implement `git add-ci`

			// the name (or abs paths of) the command to run
			//
			// command extension:
			// if cmd matches an entry in the "commands" object, they will be merged in the following way:
			// let `P` be the original command object and `Q` be the command inside the "commands" object that matches
			//
			// * Q.args, Q.attrs and Q.switch are prepended to the corresponding entries in P
			// * Q.env is merged with P.env replacing missing and otherwise falsey values inside P.env
			// falsey values are `empty string: ""`, `empty array: []`, `false`, `0`, `empty object {}`, `null`)
			"cmd": "",

			// the args to pass to the command
			"args": []
		},
	},

	"default_commands": {
		"play": {
			"save": true,
			"cmd": ".play",
			"input": true
		},
		"replay": {
			"overlay": true,
			"cid": "replay:$_wd",
			"cmd": "play",
		},
		"go install": {
			"overlay": true,
			"cmd": "go",
			"args": ["install"]
		}
	},

	// what 9o command to run when (super or )ctrl+dot,ctrl+b us pressed
	// e.g. ["go", "build"]
	// the 9o command ^1 recalls the last command you ran manually
	// see 9o help(ctrl+9 "help") for more details about what commands are supported
	"build_command": ["^1"],

	"auto_complete_triggers": [ {"selector": "source.go", "characters": "."} ],

	// exclude files with the listed prefixes from the file browsing palette (ctrl+dot,ctrl+m)
	"fn_exclude_prefixes": [".", "_"]
}
